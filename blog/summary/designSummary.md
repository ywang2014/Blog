# 架构设计总结
&emsp;&emsp;提升技术能力，提升设计技巧，增加见识和思考深度。设计能力是一个慢慢积累的过程，不是天生的，也不是什么职务，什么工作特有的，是个人自我总结、勤于思考，之后发现的。写业务代码没有前景吗，写中间件就能做架构师吗？我不这么认为，其实写业务代码也有设计，中间件缺少设计的也不少，关键在于程序员自己，程序是程序写出来的。只是常常写业务的同学缺少设计的习惯，拿着需求就干，直接低头写程序了，写中间件的同学，知道有很多场景使用，必须具体通用性，因此一开始就知道很好的设计，次数多了，自然就是写业务的同学很多不设计，写中间件的同学多数坚持设计，毕竟习惯成自然。

&emsp;&emsp;业务代码有很好的设计，和缺乏设计，还是有很多不同的。设计良好的业务系统，扩展性、灵活性非常强，支持多业务线很简单，线上问题也少很多。

&emsp;&emsp;比如常见的兜底策略，很多业务系统没有兜底策略，请求第三方服务等，不管是否有超时，有异常，都不会做重试机制。但是业务场景熟悉的同学，懂设计的同学，就知道最好有报警机制，提示有异常情况出现，有重试机制，提高系统鲁棒性。

&emsp;&emsp;重试机制，说着很简单，实际实现方式就有很多不同了。比如有直接补偿重试，简单重试3次，也有队列补偿重试等。队列也是一个技巧，队列可以放在本地，也可以放在redis等缓存系统中，也可以放在数据库中。不同的重试机制，各有优缺点，比如：本地队列存在问题是重启服务会丢失数据。直接重试，或者普通队列重试，可能只会增加服务阻塞时长，增加qps，不能真正解决问题，因为恰巧第三方服务那5秒不可用，重试3次也没有效果，因此是不是可以考虑延迟队列重试，或者定时任务补偿重试等。


好的基础架构应该像空气一样，让你没有看不见、摸不着，又不得不需要她！

好的业务系统应该像马路高速公路一样，让你正常走路，有告警、有提示，极少出故障，不可用。

**Date：2019-09-29**

## 基础服务设计原则
#### 稳定性
（基础服务尽可能保持稳定，对业务透明）
###### 服务保持向上兼容，不要轻易大改服务
既要支持未来的业务，也要支持以前使用的用户，不能让老用户现在不能正常使用，必须进行升级。历史服务，必须兼容。

    1.通过分支支持 if/else 兼容历史服务，简单易于实现，但扩展性不好。
    2.通过配置支持，比如：版本控制，类型控制等。
###### 功能变更，尽量减少修改方式，通过新增方式支持。
	1.问题修复，正常支持，但是尽可能不变更接口api
	2.升级功能，兼容历史情况。（1.历史用户，可以不动代码。2.回滚方案简单，否则回滚服务比较复杂麻烦。3.控制流量简单）
#### 简单易用性 
（服务升级，兼容双机房等，尽可能对用户透明）
###### 基础服务升级，应该帮助业务用户自动升级，告诉业务观察服务稳定性即可。减少业务同学执行一堆不懂操作，也对业务不需要的操作。
	1.脚本刷数据  写一个脚本，批量执行，刷一遍数据。
	2.懒加载策略  服务兼容历史场景，在服务升级，重新发布、部署、注册等场景中，自动添加某个配置，帮助用户自动升级。
###### 提供默认配置，默认功能。
	1.支持小白用户，或者业务场景简单的case，不需要进行复杂操作。
	2.高级用户，业务需要特别支持的，可以自行增加配置，扩展功能。
#### 可用性 
（即支持业务升级，也支持业务回滚）
###### 升级失败问题
	1.业务变更升级，如果遇到失败情况，应该支持业务快速回滚，保证业务可用性。查询问题，解决之后，再次升级。仅支持升级，不支持降级，如果业务升级失败，会导致整个服务不可用。
###### 升级时间安排问题
	1.业务变更升级，可能不能及时执行，比如上下游服务依赖，或者业务没有时间支持，应该允许业务不升级，也能正常使用，只是没有最新的功能保障。
	2.升级与否的决定权，应该在业务方，保证业务可用性。（业务方自行识别风险，不升级遇到问题，需要业务方承担后果）
## 基础服务实现原则
#### 可配置性
###### 尽可能不要写死依赖项
	1.比如需要服务发现，地址应该是可以简单配置的，不能写死，导致用户必须配置相关环境，才能正常使用。
	2.依赖的一些脚本，命令行文件，地址应该是可以简单配置的。
###### 功能可配置性
	1.不需要的功能，可以选择通过配置关闭。特别是一些必须依赖某些环境才能正常使用的功能，又不是用户必须的功能，应该支持关闭，否则用户必须配置一堆不需要的环境，支持一些不需要的功能，才能正常使用需要的功能。复杂度太高，效率太低。
	2.需要什么功能，配置什么功能。优化服务，减少服务依赖性，不必在一个非常简单的服务里面，加载全部的基础组件，而实际只需要一个组件。jar包越小越好，简洁干净。
#### 可读性
###### 错误情况尽可能准确、详细，可阅读。
	1.缺少依赖项，必须项的地方，一定要抛异常，或者打印error日志。不能直接忽略，简单返回，没有日志和异常，很难排查问题。
	2.日志内容，尽量准确，告诉用户异常原因，方便用户定位问题。不能直接就是error，需要增加具体信息说明error原因。
	3.不同的错误，最好打印不同的error内容，或者抛出不同异常message、异常类型。
###### 正常日志尽可能充分，可阅读。
	1.关键地方，最好有日志信息，日志能够方便定位、排查问题。
	2.分支路径，最好有日志信息。
	3.特别的case，最好有warn日志，提示用户，比如缺少什么内容，或者找不到什么bean之类的。可能不影响当前功能，但是不属于正常情况，可能导致其他地方功能，不能正常使用。
#### 扩展性
###### 服务一定要尽可能保持灵活、可扩展。业务变化很快，业务场景很多，尽可能支持多业务场景。
###### 多借助于设计模式，减少if else 分支等。比如：工厂模式、策略模式、构建者模式等。
###### 面向接口编程，隐藏实现细节，方便扩展。
         